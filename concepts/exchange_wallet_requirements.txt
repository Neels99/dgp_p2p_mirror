Exchange wallet requirements.

1. Безопасное хранение средств для быстрого биржевого обмена.
2. Любая транзакция на бирже происходит мгновенно.
3. Доступ к кошельку только у пользователя
4. В рамках биржевого обмена виртуальные кошельки с новыми монетами других блокчейнов также доступны только владельцу исходного кошелька.
5. Вывод средств через передачу полных прав управления кошельком или инициация владельцем исходного кошелька перевода средств на сторону
6. Возможно до начала торгов установка альтернативных кошельков для альткоинов, на которые в дальнейшем возможен исключительный вывод средств, то есть только на эти кошельки и больше ни на какие другие.


очень хотелось бы не передавать приватные ключи, а делать так чтобы они хранились изначально на машине пользователя, но доступ он к ним получал/расшифровывал только после наступления опредеелнных условий

- Хорошо. А та же супер нода может передавать паблик кей какой-нибудь? Без паблик кея не определить ведь достоверность подписи.

публичный ключ может передавать кто угодно кому угодна, его вообще по идее можно публиковать, на то он и паблик. По идее же btc адрес Это и есть

- Так я только про него и говорю. Просто, когда я сказал про передачу паблик кеев, ты мне сказал, что небезопасно все равно и не хотелось бы такого.

Public key, конечно же паблики для того и созданы чтобы ими меняться и передавать

- А я тут голову ломаю, придумываю систему, как через хэширование, не передавая паблик кеев, подпись подтвердить. Тогда всё стало проще. Намного. Кстати. Вопрос. Как насчёт того, чтобы передавать покупателю и продавцу средства разными способами?

типа асинхронно не по времени а по методу, а почему-бы и нет? Покупатель же уже может использовать скрипт в транзакции, потому что знает паблик кей продавца. если это ему позволяет блокчейн монеты

- Вопрос, ещё. Почему бы не продавцу генерировать кошелек, на который получать ему средства от покупателя?

встречный вопрос - что в таком случае с приватным ключом от созданного не им кошелька? как он его откроет, если мы приватные ключи не передаем?

- Смотри.Продавец генерит кошелек валюты[w2], которую хочет получить взамен за ту, которую продает. Отправляет пуллу адрес кошелька  в шаре с заявкой. Пулл генерит кошелек валюты[w1], которую продавец продает и передает ему адрес. Продавец переводит деньги на этот адрес[w1] и заявка получает статус Live. Теперь покупатель оформляет ответную заявку в другом шарчейне и отправляет её пуллу, после чего покупателю нужно переслать средства на созданный продавцом кошелек[w2], создав транзакцию со скриптом. После этого, через подпись, покупатель подтверждает, что перевод сделал он и получает зашифрованную его паблик кеем пару ключей от кошелька [w1]. Примерно так, в упрощенной форме. Пулл генерит кошелек валюты[w1], которую продавец продает и передает ему адрес.

как продавец может быть уверен в безопасности? этой транзакции, он должен доверять пуллу?

- Это самый первый и самый старый вопрос, что я тебе задавал. Потому что во всех концепциях, пулл генерировал кошелек, куда переводились средства и я всё ещё не знаю, как именно это безопасно хранить.

так вот я предлагаю генерить мультисиг кошелек 1/2 плюс условие, что ключ его открывает только если есть средства на обратном кошельке в нужном объхеме и работает только тот ключ условие для которого соблюдено, то есть если деньги пришли на обратные кошелек, то работает ключ пула, если деньги не пришли и время истекло, то становится валидным ключ продавца, то есть комбинация мультиподписи и скрипта-условия

- Сейчас, думаю, насколько реально реализовать такой скрипт.

Только это самая простая схема внутри все сложнее будет, потому ячто у пула тоже должен быть очень хитрый ключ, который позволяет только одну операцию, а именно одновременная передача одних средств в обмен на другие, то есть ключ этот и есть по сути скрипт, который становится валидным и запускаемям, если встречное предложение подтверждено наличием средств на встречном кошельке

- Сейчас, надо понять, можно ли будет такую проверку кеев сделать. 

При этом такая проверка должна происходить на нодах и децентрализовано с подтверждением валидности несколькими разными нодами зашивая эти подтверждения в какое-то количество сгенерированных шар

- Нодами вне п2пулла? 

нет, именно нодами пула, которые должны с помощью проделанной майнерами работы

- А, это вполне возможно. 

Зашивать это в шары, и после определенного их количества исполнять скрипт обмена

- Стоп. Скрипт обмена? 

Ну то есть переброс одновременный между кошельками, скрипт - он-же ключ

- Так. Ты говоришь про одновременный переброс кошельками. Ты про передачу пары ключей пуллом покупателю/продавцу? 

Это должны быть ключи, которые уже есть у покупателя и продавца, приватные, которые никуда не перемещаются, а должны быть у них сразу но они не работают и не валидны, пока пулл не подтвердит в нескольких шарах, что все состоялось и условие выполнено, то есть несколько узлов должны проверить эти условия и записать в очередную шару, и ключ становится валидным например после 60 шар, что тоже часть условия, 60 - пока с потолка, зависит от скорости генерации шар, сложности сети и еще кучи всего. Следующий узел проверяет предыдущую шару и добавляет свою проверку и т.д. По тому-же принципу как проверяется генерация монеты, то есть это часть подзаголовка блока, дополлняемая пуллом, 

- это должны быть ключи. Я понимаю, как это работает. Я не могу понять, что конкретно за ключи? Ключи для подписи? Кошелёк биткойн и прочих блокчейнов? Или ключи для безопасного обмена данными?

Ключ для возможности подписывать транзакции, для распоряжения средствами, то есть пул и клиент (не важно продавец или покупатель) генерят 2/1 кошелек, но приватные ключи обеих сторон сразу не работают, то есть 1/2 кошелек , в котором для распоряжения средствами нужна любая одна из двух подписей, возможно даже, надо подумать, как сделать так чтобы можно уже после создания такого кошелька у пула была возможность не распоряжаться транзакцией а имет возможность добавить третью подпись другой стороны чтобы кошелек мутировал в 1/3 то есть у пулла даже не совсем ключ для управления балансом а скорее какой-то служебный ключ который как-то хитро может использоваться только для того, чтобы добавить третью подпись (или полноценную вторую, если считать что ключ пулла только служит для добавления владельцев кошелька через публичный ключ) и одновременно с добавлением делать не валидной подпись первого клиента
или другой вариант, когда кошелек изначально 2/2, но ключ пулла позволяет добавить еще одного участника, чтобы он стал 2/3, тогда пул проверив условия подписывает только транзакции которые делает владелец второго или первого ключа, в зависимочсти от того какие условия выполнены/не выполнены

- Скажу, что реализация некоторого из того, что ты написал выше, стоила бы нам при её продаже дороже, чем реализация самой биржи, которая это использует. Невозможно поменять правила подписи, но сейчас подумаю, как бы нам проверку условий безопасную сделать. 

Невозможно поменять правила подписи Думаешь в эту сторону не прокопать?

- Да, это фактически невозможно. Другой же хэш будет. Нет, если внутри пулла все происходит, а не про подписи блокчейн кошельков говорим, то там правила изменения, какие хочешь пили.  Но у биткойн скриптов такого функционала нет. Да и других блокчейнов. 

Если ты про то что для реализации надо менять правила основных блокчейнов, я конечно же говорю про реализацию в шарчейне,

- А, так в шарчейне можно что угодно сделать. 

не противорячящее законам физики и математики

- Смотри. А что конкретно внутри шарчейна мы подписываем? 

Нода шарчейна - по сути core кошелек кошелек проверяет два основных условия
1. решение работы майнерами
2. меркл три транзакций

- Кошелёк внутри блокчейна ведь, а не наш собственный кошелёк? 

Нода шарчейна - по сути core кошелек, но это кошелек не монеты, а работы майнеров, тот же ведь принцип, только самих монет в нем не рождается, имено шарчейновских, вот у нас с тобой и выбор, мы можем это как в задачу 1 вписать, то есть генерация монет алгоритмом щарчейна = генерация структуры подтвержения обменных операций
или во вторую, где дерево меркла, и транзакции, а может и гибридное решение сделать

From book:

Efficient micro-payments. A third example of Bitcoin scripts is a way to do efficient micro-payments.
Say that Alice is a customer who wants to continually pay Bob small amounts of money for some
service that Bob provides. For example, Bob may be Alice’s wireless service provider, and requires her
to pay a small fee for every minute that she talks on her phone.
Creating a Bitcoin transaction for every minute that Alice speaks on the phone won’t work. That will
create too many transactions, and the transaction fees add up. If the value of each one of these
transactions is on the order of what the transaction fees are, Alice is going to be paying quite a high
cost to do this.
What we’d like is to be able to combine all these small payments into one big payment at the end. It
turns out that there’s a neat way to do this. We start with a MULTISIG transaction that pays the
maximum amount Alice would ever need to spend to an output requiring both Alice and Bob to sign
to release the coins. Now, after the first minute that Alice has used the service, or the first time Alice
needs to make a micropayment, she signs a transaction spending those coins that were sent to the
MULTISIG address, sending one unit of payment to Bob and returning the rest to Alice. After the next
minute of using the service, Alice signs another transaction, this time paying two units to Bob and
sending the rest to herself. Notice these are signed only by Alice, and haven’t been signed by Bob yet,
nor are they being published to the block chain. Alice will keep sending these transactions to Bob
every minute that she uses the service. Eventually, Alice will finish using the service, and tells Bob,
“I’m done, please cut off my service.” At this point Alice will stop signing additional transactions. Upon
hearing this, Bob will say “Great. I’ll disconnect your service, and I’ll take that last transaction that you
sent me, sign it, and publish that to the block chain.”
Since each transaction was paying Bob a little bit more, and Alice a little bit less, the final transaction
that Bob redeems pays him in full for the service that he provided and returns the rest of the money
to Alice. All those transactions that Alice signed along the way won’t make it to the block chain. Bob
doesn’t have to sign them. They’ll just get discarded.
86
Technically all of these transactions are double-spends. So unlike the case with green addresses
where we were specifically trying to avoid double-spends, with a strong guarantee, with this
micro-payment protocol, we’re actually generating a huge amount of potential double-spends. In
practice, however, if both parties are operating normally, Bob will never sign any transaction but the
last one, in which case the block chain won’t actually see any attempt at a double-spend.
There’s one other tricky detail: what if Bob never signs the last transaction? He may just say, “I’m
happy to let the coins sit there in escrow forever,” in which case, maybe the coins won’t move, but
Alice will lose the full value that she paid at the beginning. There’s a very clever way to avoid this
problem using a feature that we mentioned briefly earlier, and will explain now.
Lock time. To avoid this problem, before the micro-payment protocol can even start, Alice and Bob
will both sign a transaction which refunds all of Alice’s money back to her, but the refund is “locked”
until some time in the future. So after Alice signs, but before she broadcasts, the first MULTISIG
transaction that puts her funds into escrow, she’ll want to get this refund transaction from Bob and
hold on to it. That guarantees that if she makes it to time t and Bob hasn’t signed any of the small
transactions that Alice has sent, Alice can publish this transaction which refunds all of the money
directly to her.
What does it mean that it’s locked until time t? Recall when we looked at the metadata in Bitcoin
transactions, that there was this lock_time parameter, which we had left unexplained. The way it
works is that if you specify any value other than zero for the lock time, it tells miners not to publish
the transaction until the specified lock time. The transaction will be invalid before either a specific
block number, or a specific point in time, based on the timestamps that are put into blocks. So this is a
way of preparing a transaction that can only be spent in the future if it isn’t already spent by then. It
works quite nicely in the micro-payment protocol as a safety valve for Alice to know that if Bob never
signs, eventually she’ll be able to get her money back.
Hopefully, these examples have shown you that we can do some neat stuff with Bitcoin scripts. We
discussed three simple and practical examples, but there are many others that have been researched.
One of them is multi-player lotteries, a very complicated multi-step protocol with lots of transactions
having different lock times and escrows in case people cheat. There are also some neat protocols that
utilize the scripting language to allow different people to get their coins together and mix them, so
that it’s harder to trace who owns which coin. We’ll see that in detail in Chapter 6.
